// å¡žé›·å¡ä»»åŠ¡JSONå¯¼å…¥å¯¼å‡ºå·¥å…·

export class SerekaTaskConverter {
  // å°†ç¼–è¾‘å™¨èŠ‚ç‚¹è½¬æ¢ä¸ºå¡žé›·å¡JSONæ ¼å¼
  static toSerekaJSON(nodes, edges) {
    const result = {
      title: '',
      description: '',
      listmission: true,
      addtitleinlist: false,
      addtitleinpanel: false,
      zones: [],
      checkpoints: [],
      dialogue_nodes: [],
      subconditions: [],
      editorPositions: []
    };

    // æŒ‰èŠ‚ç‚¹ç±»åž‹åˆ†ç±»å¤„ç†
    nodes.forEach(node => {
      // ZoneContainerèŠ‚ç‚¹ç‰¹æ®Šå¤„ç†
      if (node.type === 'zoneContainer') {
        if (node.data.zones && node.data.zones.length > 0) {
          node.data.zones.forEach(zone => {
            result.zones.push({
              id: zone.id,
              areas: [{
                type: zone.areaType || 'sphere',
                stage: zone.stage || 'Apart',
                x: zone.x || 0,
                y: zone.y || 0,
                z: zone.z || 0,
                r: zone.r || 0.5,
                outlinehidden: zone.outlinehidden || false,
                compasshidden: zone.compasshidden || false,
                visualGuides: zone.ringEnabled ? {
                  ringEffect: {
                    enabled: true,
                    color: zone.ringColor || { r: 0, g: 1, b: 0, a: 0.8 },
                    radius: zone.r || 0.5
                  }
                } : undefined
              }]
            });
          });
        }
        
        // ä¿å­˜å®¹å™¨ä½ç½®
        result.editorPositions.push({
          id: 'zone_container',
          x: Math.round(node.position.x),
          y: Math.round(node.position.y)
        });
        return;
      }

      const { nodeTemplate, formData } = node.data;
      
      switch (nodeTemplate.type) {
        case 'missionInfo':
          result.title = formData.title || '';
          result.description = formData.description || '';
          result.listmission = formData.listmission !== undefined ? formData.listmission : true;
          result.addtitleinlist = formData.addtitleinlist || false;
          result.addtitleinpanel = formData.addtitleinpanel || false;
          result.stage = formData.stage || 'Apart';
          break;

        case 'teleport':
          result.startPosition = {
            stage: formData.stage || 'Apart',
            x: formData.x || 0,
            y: formData.y || 0,
            z: formData.z || 0,
            description: formData.description || 'ä»»åŠ¡ä¼ é€èµ·ç‚¹'
          };
          break;

        case 'zone':
          // ä¿ç•™å¯¹æ—§æ ¼å¼çš„æ”¯æŒ
          result.zones.push({
            id: formData.id || `zone_${node.id}`,
            areas: [{
              type: formData.areaType || 'sphere',
              stage: formData.stage || 'Apart',
              x: formData.x || 0,
              y: formData.y || 0,
              z: formData.z || 0,
              r: formData.r || 0.5,
              outlinehidden: formData.outlinehidden || false,
              compasshidden: formData.compasshidden || false,
              visualGuides: formData.ringEnabled ? {
                ringEffect: {
                  enabled: true,
                  color: formData.ringColor || { r: 0, g: 1, b: 0, a: 0.8 },
                  radius: formData.r || 0.5
                }
              } : undefined
            }]
          });
          break;

        case 'checkpoint':
          result.checkpoints.push({
            id: formData.id || `node_${node.id}`,
            zone: formData.zone || '',
            condition: {
              condition: formData.condition || '',
              description: formData.description || '',
              duration: formData.duration || 1,
              rp: formData.rp || 0,
              reset: formData.reset !== undefined ? formData.reset : true,
              hidepanel: formData.hidepanel || ''
            },
            nextcheckpoint: formData.nextcheckpoint || ''
          });
          break;

        case 'dialogue':
          result.dialogue_nodes.push({
            id: formData.id || `dialogue_${node.id}`,
            lines: formData.lines || [],
            nextcheckpoint: formData.nextcheckpoint || ''
          });
          break;

        case 'condition':
          result.subconditions.push({
            id: formData.id || `condition_${node.id}`,
            condition: formData.condition || ''
          });
          break;
      }

      // ä¿å­˜ç¼–è¾‘å™¨ä¸­çš„èŠ‚ç‚¹ä½ç½®
      result.editorPositions.push({
        id: formData.id || node.id,
        x: Math.round(node.position.x),
        y: Math.round(node.position.y)
      });
    });

    // æ¸…ç†ç©ºæ•°ç»„
    if (result.zones.length === 0) delete result.zones;
    if (result.checkpoints.length === 0) delete result.checkpoints;
    if (result.dialogue_nodes.length === 0) delete result.dialogue_nodes;
    if (result.subconditions.length === 0) delete result.subconditions;

    return result;
  }

  // ä»Žå¡žé›·å¡JSONæ ¼å¼è½¬æ¢ä¸ºç¼–è¾‘å™¨èŠ‚ç‚¹
  static fromSerekaJSON(json) {
    const nodes = [];
    const edges = [];
    let nodeIdCounter = 1;
    
    // å¸ƒå±€é…ç½®
    const layout = {
      startX: 50,
      startY: 50,
      nodeWidth: 300,
      nodeHeight: 180,
      horizontalSpacing: 150,
      verticalSpacing: 120,
      
      // åŒºåŸŸå¸ƒå±€
      zoneContainerX: 50,
      zoneContainerY: 50,
      zoneContainerWidth: 800,
      zoneContainerHeight: 300,
      
      // å­æ¡ä»¶å¸ƒå±€
      subConditionX: 900,
      subConditionY: 50,
      subConditionWidth: 700,
      subConditionHeight: 250,
      
      // ä»»åŠ¡ä¿¡æ¯å¸ƒå±€
      missionInfoX: 50,
      missionInfoY: 400,
      
      // ä¼ é€ç‚¹å¸ƒå±€
      teleportX: 400,
      teleportY: 400,
      
      // æ£€æŸ¥ç‚¹æµç¨‹èµ·ç‚¹
      checkpointStartX: 50,
      checkpointStartY: 650
    };

    // æå–ç¼–è¾‘å™¨ä½ç½®ä¿¡æ¯ï¼ˆå¦‚æžœæœ‰ï¼‰
    const editorPositions = json.editorPositions || [];
    const hasEditorPositions = editorPositions.length > 0;
    
    const getPosition = (id, defaultX, defaultY) => {
      if (!hasEditorPositions) return { x: defaultX, y: defaultY };
      const pos = editorPositions.find(p => p.id === id);
      return pos ? { x: pos.x, y: pos.y } : { x: defaultX, y: defaultY };
    };

    // 1. åˆ›å»ºåœ°ç‚¹å®¹å™¨èŠ‚ç‚¹ï¼ˆçŸ©å½¢ç½‘æ ¼å¸ƒå±€ï¼‰
    if (json.zones && json.zones.length > 0) {
      const zoneContainerId = `zone_container_${nodeIdCounter++}`;
      
      const zonesData = json.zones.map((zone) => {
        const area = zone.areas[0];
        return {
          id: zone.id,
          stage: area.stage,
          x: area.x,
          y: area.y,
          z: area.z,
          r: area.r,
          areaType: area.type,
          outlinehidden: area.outlinehidden,
          compasshidden: area.compasshidden,
          ringEnabled: area.visualGuides?.ringEffect?.enabled || false,
          ringColor: area.visualGuides?.ringEffect?.color || { r: 0, g: 1, b: 0, a: 0.8 }
        };
      });
      
      const zoneContainerNode = {
        id: zoneContainerId,
        type: 'zoneContainer',
        position: getPosition('zone_container', layout.zoneContainerX, layout.zoneContainerY),
        style: { width: layout.zoneContainerWidth, height: layout.zoneContainerHeight },
        data: {
          zones: zonesData,
          label: 'åœ°ç‚¹åˆ—è¡¨'
        }
      };
      nodes.push(zoneContainerNode);
    }

    // 2. åˆ›å»ºå­æ¡ä»¶å®¹å™¨èŠ‚ç‚¹ï¼ˆçŸ©å½¢ç½‘æ ¼å¸ƒå±€ï¼‰
    if (json.subconditions && json.subconditions.length > 0) {
      const subCondContainerId = `subcond_container_${nodeIdCounter++}`;
      
      const subConditionsData = json.subconditions.map((subcond) => ({
        id: subcond.id,
        condition: subcond.condition
      }));
      
      const subCondContainerNode = {
        id: subCondContainerId,
        type: 'subConditionContainer',
        position: getPosition('subcond_container', layout.subConditionX, layout.subConditionY),
        style: { width: layout.subConditionWidth, height: layout.subConditionHeight },
        data: {
          subconditions: subConditionsData,
          label: 'å­æ¡ä»¶åˆ—è¡¨'
        }
      };
      nodes.push(subCondContainerNode);
    }

    // 3. åˆ›å»ºä»»åŠ¡ä¿¡æ¯èŠ‚ç‚¹
    if (json.title || json.description) {
      const missionNode = {
        id: `${nodeIdCounter++}`,
        type: 'serekaTaskNode',
        position: getPosition('mission_info', layout.missionInfoX, layout.missionInfoY),
        data: {
          nodeTemplate: {
            type: 'missionInfo',
            category: 'åŸºç¡€è®¾ç½®',
            label: 'ä»»åŠ¡ä¿¡æ¯',
            icon: 'ðŸ“‹',
            color: '#4CAF50',
            fields: []
          },
          formData: {
            title: json.title || '',
            description: json.description || '',
            listmission: json.listmission,
            addtitleinlist: json.addtitleinlist,
            addtitleinpanel: json.addtitleinpanel,
            stage: json.stage || 'Apart'
          }
        }
      };
      nodes.push(missionNode);
    }

    // 4. åˆ›å»ºä¼ é€ç‚¹èŠ‚ç‚¹
    if (json.startPosition) {
      const teleportNode = {
        id: `${nodeIdCounter++}`,
        type: 'serekaTaskNode',
        position: getPosition('start_position', layout.teleportX, layout.teleportY),
        data: {
          nodeTemplate: {
            type: 'teleport',
            category: 'ä¼ é€ç‚¹',
            label: 'ä¼ é€ç‚¹',
            icon: 'ðŸŒ€',
            color: '#9C27B0',
            fields: []
          },
          formData: json.startPosition
        }
      };
      nodes.push(teleportNode);
    }

    // 5. åˆ›å»ºæ£€æŸ¥ç‚¹æµç¨‹ï¼ˆçº¿æ€§æˆ–åˆ†æ”¯å¸ƒå±€ï¼‰
    const checkpointMap = {};
    
    if (json.checkpoints && json.checkpoints.length > 0) {
        inDegree[cp.id] = 0;
      });
      
      checkpoints.forEach(cp => {
        if (cp.nextcheckpoint) {
          graph[cp.id].push(cp.nextcheckpoint);
          inDegree[cp.nextcheckpoint] = (inDegree[cp.nextcheckpoint] || 0) + 1;
        }
      });
      
      return { graph, inDegree };
    };
    
    // è¾…åŠ©å‡½æ•°ï¼šæŸ¥æ‰¾èµ·å§‹èŠ‚ç‚¹ï¼ˆæ²¡æœ‰å‰é©±çš„èŠ‚ç‚¹ï¼‰
    const findStartNodes = (checkpoints, inDegree) => {
      return checkpoints.filter(cp => inDegree[cp.id] === 0).map(cp => cp.id);
    };
    
    // è¾…åŠ©å‡½æ•°ï¼šæ‹“æ‰‘æŽ’åºå¹¶åˆ†å±‚
    const topologicalSort = (checkpoints) => {
      const { graph, inDegree } = buildDependencyGraph(checkpoints);
      const startNodes = findStartNodes(checkpoints, inDegree);
      
      const layers = [];
      const visited = new Set();
      const queue = startNodes.map(id => ({ id, layer: 0 }));
      
      while (queue.length > 0) {
        const { id, layer } = queue.shift();
        if (visited.has(id)) continue;
        
        visited.add(id);
        
        if (!layers[layer]) layers[layer] = [];
        layers[layer].push(id);
        
        const nextNodes = graph[id] || [];
        nextNodes.forEach(nextId => {
          if (!visited.has(nextId)) {
            queue.push({ id: nextId, layer: layer + 1 });
          }
        });
      }
      
      return layers;
    };
    
    if (json.checkpoints && json.checkpoints.length > 0) {
      // æž„å»ºæ£€æŸ¥ç‚¹åˆ†å±‚ç»“æž„
      const layers = topologicalSort(json.checkpoints);
      const checkpointById = {};
      json.checkpoints.forEach(cp => checkpointById[cp.id] = cp);
      
      let flowX = layout.flowStartX;
      
      layers.forEach((layer, layerIndex) => {
        const layerY = layout.startY;
        const nodesInLayer = layer.length;
        
        layer.forEach((checkpointId, indexInLayer) => {
          const checkpoint = checkpointById[checkpointId];
          if (!checkpoint) return;
          
          const nodeId = `${nodeIdCounter++}`;
          checkpointMap[checkpoint.id] = nodeId;
          
          // è®¡ç®—Yåæ ‡ï¼šå¦‚æžœæœ‰å¤šä¸ªèŠ‚ç‚¹åœ¨åŒä¸€å±‚ï¼Œåž‚ç›´åˆ†å¸ƒ
          let y = layerY;
          if (nodesInLayer > 1) {
            // åˆ†æ”¯æƒ…å†µï¼šåž‚ç›´åˆ†æ•£
            const totalHeight = (nodesInLayer - 1) * (layout.nodeHeight + layout.verticalSpacing);
            const startY = layerY - totalHeight / 2;
            y = startY + indexInLayer * (layout.nodeHeight + layout.verticalSpacing);
          }
          
          const checkpointNode = {
            id: nodeId,
            type: 'serekaTaskNode',
            position: getPosition(checkpoint.id, flowX, y),
            data: {
              nodeTemplate: {
                type: 'checkpoint',
                category: 'æ£€æŸ¥ç‚¹',
                label: 'æ£€æŸ¥ç‚¹',
                icon: 'âœ…',
                color: '#FF9800',
                fields: []
              },
              formData: {
                id: checkpoint.id,
                zone: checkpoint.zone,
                description: checkpoint.condition?.description || '',
                condition: checkpoint.condition?.condition || '',
                duration: checkpoint.condition?.duration || 1,
                rp: checkpoint.condition?.rp || 0,
                reset: checkpoint.condition?.reset,
                hidepanel: checkpoint.condition?.hidepanel || '',
                nextcheckpoint: checkpoint.nextcheckpoint || ''
              }
            }
          };
          nodes.push(checkpointNode);
        });
        
        flowX += layout.nodeWidth + layout.horizontalSpacing;
      });
    }

    // 5. åˆ›å»ºå¯¹è¯èŠ‚ç‚¹ï¼ˆæ’å…¥åˆ°æµç¨‹å›¾ä¸­ï¼‰
    if (json.dialogue_nodes && json.dialogue_nodes.length > 0) {
      // å¯¹è¯èŠ‚ç‚¹éœ€è¦æ ¹æ®å®ƒä»¬åœ¨æµç¨‹ä¸­çš„ä½ç½®æ¥å¸ƒå±€
      json.dialogue_nodes.forEach((dialogue) => {
        const nodeId = `${nodeIdCounter++}`;
        dialogueMap[dialogue.id] = nodeId;
        
        // æŸ¥æ‰¾å¼•ç”¨æ­¤å¯¹è¯çš„æ£€æŸ¥ç‚¹ï¼Œæ”¾åœ¨å…¶é™„è¿‘
        let posX = layout.flowStartX;
        let posY = layout.startY + 200;
        
        // å°è¯•æ‰¾åˆ°å¼•ç”¨æ­¤å¯¹è¯çš„å‰ç½®èŠ‚ç‚¹
        if (json.checkpoints) {
          const refCheckpoint = json.checkpoints.find(cp => cp.nextcheckpoint === dialogue.id);
          if (refCheckpoint && checkpointMap[refCheckpoint.id]) {
            const refNode = nodes.find(n => n.id === checkpointMap[refCheckpoint.id]);
            if (refNode) {
              posX = refNode.position.x + layout.nodeWidth + layout.horizontalSpacing;
              posY = refNode.position.y;
            }
          }
        }
        
        const dialogueNode = {
          id: nodeId,
          type: 'serekaTaskNode',
          position: getPosition(dialogue.id, posX, posY),
          data: {
            nodeTemplate: {
              type: 'dialogue',
              category: 'å¯¹è¯èŠ‚ç‚¹',
              label: 'å¯¹è¯èŠ‚ç‚¹',
              icon: 'ðŸ’¬',
              color: '#E91E63',
              fields: []
            },
            formData: {
              id: dialogue.id,
              lines: dialogue.lines || [],
              nextcheckpoint: dialogue.nextcheckpoint || ''
            }
          }
        };
        nodes.push(dialogueNode);
      });
    }

    // 6. åˆ›å»ºå­æ¡ä»¶èŠ‚ç‚¹ï¼ˆæ”¾åœ¨å·¦ä¸‹è§’ï¼‰
    if (json.subconditions && json.subconditions.length > 0) {
      let condY = layout.startY + 400;
      json.subconditions.forEach((condition, index) => {
        const nodeId = `${nodeIdCounter++}`;
        
        const conditionNode = {
          id: nodeId,
          type: 'serekaTaskNode',
          position: getPosition(condition.id, layout.startX, condY + index * (layout.nodeHeight + layout.verticalSpacing)),
          data: {
            nodeTemplate: {
              type: 'condition',
              category: 'æ¡ä»¶åˆ¤æ–­',
              label: 'å­æ¡ä»¶',
              icon: 'ðŸ”€',
              color: '#00BCD4',
              fields: []
            },
            formData: {
              id: condition.id,
              condition: condition.condition
            }
          }
        };
        nodes.push(conditionNode);
      });
    }

    // 7. åˆ›å»ºæµç¨‹è¿žæŽ¥ï¼ˆåŸºäºŽnextcheckpointï¼‰
    const allNodeMap = { ...checkpointMap, ...dialogueMap };
    
    // æ£€æŸ¥ç‚¹ä¹‹é—´çš„æµç¨‹è¿žæŽ¥
    if (json.checkpoints) {
      json.checkpoints.forEach(checkpoint => {
        const sourceId = checkpointMap[checkpoint.id];
        if (checkpoint.nextcheckpoint && sourceId) {
          const targetId = allNodeMap[checkpoint.nextcheckpoint];
          if (targetId) {
            edges.push({
              id: `e-flow-${sourceId}-${targetId}`,
              source: sourceId,
              target: targetId,
              type: 'smoothstep',
              animated: true,
              style: { stroke: '#4CAF50', strokeWidth: 2 },
              label: 'ä¸‹ä¸€æ­¥'
            });
          }
        }
      });
    }
    
    // å¯¹è¯èŠ‚ç‚¹çš„æµç¨‹è¿žæŽ¥
    if (json.dialogue_nodes) {
      json.dialogue_nodes.forEach(dialogue => {
        const sourceId = dialogueMap[dialogue.id];
        if (dialogue.nextcheckpoint && sourceId) {
          const targetId = allNodeMap[dialogue.nextcheckpoint];
          if (targetId) {
            edges.push({
              id: `e-flow-${sourceId}-${targetId}`,
              source: sourceId,
              target: targetId,
              type: 'smoothstep',
              animated: true,
              style: { stroke: '#E91E63', strokeWidth: 2 }
            });
          }
        }
      });
    }

    return { nodes, edges };
  }
}
