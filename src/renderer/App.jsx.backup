import React, { useCallback, useState, useRef } from 'react';
import ReactFlow, {
  MiniMap,
  Controls,
  Background,
  useNodesState,
  useEdgesState,
  addEdge,
  Panel,
} from 'reactflow';
import 'reactflow/dist/style.css';

import SerekaTaskNode from './components/SerekaTaskNode';
import ZoneContainer from './components/ZoneContainer';
import SubConditionContainer from './components/SubConditionContainer';
import CategorySidebar from './components/CategorySidebar';
import PropertyPanel from './components/PropertyPanel';
import TabBar from './components/TabBar';
import { SerekaTaskConverter } from './utils/taskConverter';
import './App.css';

const nodeTypes = {
  serekaTaskNode: SerekaTaskNode,
  zoneContainer: ZoneContainer,
  subConditionContainer: SubConditionContainer,
};

function App() {
  // å¤šæ ‡ç­¾é¡µçŠ¶æ€
  const [tabs, setTabs] = useState([
    { id: 1, name: 'æœªå‘½åä»»åŠ¡', nodes: [], edges: [] }
  ]);
  const [activeTabId, setActiveTabId] = useState(1);
  const tabIdCounter = useRef(2);
  
  // å½“å‰æ ‡ç­¾é¡µçš„æ•°æ®
  const activeTab = tabs.find(t => t.id === activeTabId) || tabs[0];
  const [nodes, setNodes, onNodesChange] = useNodesState(activeTab.nodes);
  const [edges, setEdges, onEdgesChange] = useEdgesState(activeTab.edges);
  
  const [selectedNode, setSelectedNode] = useState(null);
  const [showPropertyPanel, setShowPropertyPanel] = useState(false);
  const fileInputRef = useRef(null);
  let nodeIdCounter = useRef(1);

  // åŒæ­¥å½“å‰æ ‡ç­¾é¡µçš„nodeså’Œedgesåˆ°tabsçŠ¶æ€
  const syncCurrentTab = useCallback(() => {
    setTabs(prevTabs => prevTabs.map(tab => 
      tab.id === activeTabId ? { ...tab, nodes, edges } : tab
    ));
  }, [activeTabId, nodes, edges]);

  // ç›‘å¬nodeså’Œedgeså˜åŒ–ï¼ŒåŒæ­¥åˆ°tabs
  React.useEffect(() => {
    syncCurrentTab();
  }, [nodes, edges]);

  // æ ‡ç­¾é¡µæ“ä½œ
  const handleNewTab = useCallback(() => {
    const newTab = {
      id: tabIdCounter.current++,
      name: 'æœªå‘½åä»»åŠ¡',
      nodes: [],
      edges: []
    };
    setTabs(prev => [...prev, newTab]);
    setActiveTabId(newTab.id);
    setNodes([]);
    setEdges([]);
  }, [setNodes, setEdges]);

  const handleTabClick = useCallback((tabId) => {
    const tab = tabs.find(t => t.id === tabId);
    if (tab) {
      setActiveTabId(tabId);
      setNodes(tab.nodes);
      setEdges(tab.edges);
      setSelectedNode(null);
      setShowPropertyPanel(false);
    }
  }, [tabs, setNodes, setEdges]);

  const handleTabClose = useCallback((tabId) => {
    if (tabs.length === 1) return; // è‡³å°‘ä¿ç•™ä¸€ä¸ªæ ‡ç­¾é¡µ
    
    const newTabs = tabs.filter(t => t.id !== tabId);
    setTabs(newTabs);
    
    if (activeTabId === tabId) {
      const newActiveTab = newTabs[0];
      setActiveTabId(newActiveTab.id);
      setNodes(newActiveTab.nodes);
      setEdges(newActiveTab.edges);
    }
  }, [tabs, activeTabId, setNodes, setEdges]);

  const onConnect = useCallback(
    (params) => setEdges((eds) => addEdge({ ...params, type: 'smoothstep' }, eds)),
    [setEdges]
  );

  const onAddNode = useCallback((nodeTemplate) => {
    const newNode = {
      id: `node_${nodeIdCounter.current++}`,
      type: 'serekaTaskNode',
      position: {
        x: Math.random() * 300 + 250,
        y: Math.random() * 300 + 100,
      },
      data: {
        nodeTemplate: nodeTemplate,
        formData: nodeTemplate.fields.reduce((acc, field) => {
          acc[field.name] = field.default;
          return acc;
        }, {})
      },
    };
    setNodes((nds) => nds.concat(newNode));
  }, [setNodes]);

  const onAddCustomNode = useCallback(() => {
    alert('è‡ªå®šä¹‰èŠ‚ç‚¹åŠŸèƒ½å³å°†æ¨å‡ºï¼\næ‚¨å¯ä»¥åœ¨è¿™é‡Œåˆ›å»ºè‡ªå·±çš„èŠ‚ç‚¹ç±»å‹ã€‚');
  }, []);

  const onNodeClick = useCallback((event, node) => {
    setSelectedNode(node);
    setShowPropertyPanel(true);
  }, []);

  const onPaneClick = useCallback(() => {
    setSelectedNode(null);
    setShowPropertyPanel(false);
  }, []);

  const onUpdateNode = useCallback((nodeId, formData) => {
    setNodes((nds) =>
      nds.map((node) => {
        if (node.id === nodeId) {
          return {
            ...node,
            data: {
              ...node.data,
              formData: formData,
            },
          };
        }
        return node;
      })
    );
  }, [setNodes]);

  const onSaveWorkflow = useCallback(() => {
    const serekaJSON = SerekaTaskConverter.toSerekaJSON(nodes, edges);
    const jsonString = JSON.stringify(serekaJSON, null, 2);
    
    // ä¸‹è½½JSONæ–‡ä»¶
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${serekaJSON.title || 'å¡é›·å¡ä»»åŠ¡'}_${Date.now()}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    console.log('ä¿å­˜çš„ä»»åŠ¡JSON:', serekaJSON);
    alert('ä»»åŠ¡å·²å¯¼å‡ºä¸ºJSONæ–‡ä»¶ï¼');
  }, [nodes, edges]);

  const onLoadWorkflow = useCallback(() => {
    fileInputRef.current?.click();
  }, []);

  const handleFileLoad = useCallback((event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const json = JSON.parse(e.target.result);
        const { nodes: newNodes, edges: newEdges } = SerekaTaskConverter.fromSerekaJSON(json);
        setNodes(newNodes);
        setEdges(newEdges);
        
        // æ›´æ–°å½“å‰æ ‡ç­¾é¡µåç§°
        setTabs(prevTabs => prevTabs.map(tab => 
          tab.id === activeTabId 
            ? { ...tab, name: json.title || file.name.replace('.json', ''), nodes: newNodes, edges: newEdges }
            : tab
        ));
        
        alert(`æˆåŠŸå¯¼å…¥ä»»åŠ¡ï¼š${json.title || 'æœªå‘½å'}`);
      } catch (error) {
        console.error('JSONè§£æé”™è¯¯:', error);
        alert('å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®');
      }
    };
    reader.readAsText(file);
    event.target.value = '';
  }, [setNodes, setEdges, activeTabId]);
      try {
        const json = JSON.parse(e.target.result);
        const { nodes: loadedNodes, edges: loadedEdges } = SerekaTaskConverter.fromSerekaJSON(json);
        
        setNodes(loadedNodes);
        setEdges(loadedEdges);
        
        // æ›´æ–°èŠ‚ç‚¹IDè®¡æ•°å™¨
        const maxId = Math.max(...loadedNodes.map(n => parseInt(n.id.replace(/\D/g, '')) || 0), 0);
        nodeIdCounter.current = maxId + 1;
        
        alert(`æˆåŠŸåŠ è½½ä»»åŠ¡: ${json.title || 'æœªå‘½åä»»åŠ¡'}`);
      } catch (error) {
        console.error('åŠ è½½ä»»åŠ¡å¤±è´¥:', error);
        alert('åŠ è½½ä»»åŠ¡å¤±è´¥ï¼è¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼æ˜¯å¦æ­£ç¡®ã€‚');
      }
    };
    reader.readAsText(file);
    
    // é‡ç½®æ–‡ä»¶è¾“å…¥
    event.target.value = '';
  }, [setNodes, setEdges]);

  const onClearWorkflow = useCallback(() => {
    if (window.confirm('ç¡®å®šè¦æ¸…ç©ºå½“å‰å·¥ä½œæµå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
      setNodes([]);
      setEdges([]);
      setSelectedNode(null);
      setShowPropertyPanel(false);
      nodeIdCounter.current = 1;
    }
  }, [setNodes, setEdges]);

  return (
    <div className="app">
      <div className="header">
        <h1>ğŸ® å¡é›·å¡ä»»åŠ¡å·¥ä½œæµç¼–è¾‘å™¨</h1>
        <div className="header-actions">
          <button onClick={onLoadWorkflow} className="btn-load">ğŸ“‚ å¯¼å…¥ä»»åŠ¡</button>
          <button onClick={onSaveWorkflow} className="btn-save">ğŸ’¾ å¯¼å‡ºä»»åŠ¡</button>
          <button onClick={onClearWorkflow} className="btn-clear">ğŸ—‘ï¸ æ¸…ç©º</button>
        </div>
      </div>
      
      <input
        ref={fileInputRef}
        type="file"
        accept=".json"
        onChange={handleFileLoad}
        style={{ display: 'none' }}
      />
      
      <div className="main-content">
        <CategorySidebar onAddNode={onAddNode} onAddCustomNode={onAddCustomNode} />
        
        <div className="flow-container">
          <ReactFlow
            nodes={nodes}
            edges={edges}
            onNodesChange={onNodesChange}
            onEdgesChange={onEdgesChange}
            onConnect={onConnect}
            onNodeClick={onNodeClick}
            onPaneClick={onPaneClick}
            nodeTypes={nodeTypes}
            fitView
            snapToGrid
            snapGrid={[15, 15]}
          >
            <Panel position="top-right">
              <div className="info-panel">
                <div className="info-item">
                  <span className="info-label">èŠ‚ç‚¹:</span>
                  <span className="info-value">{nodes.length}</span>
                </div>
                <div className="info-item">
                  <span className="info-label">è¿æ¥:</span>
                  <span className="info-value">{edges.length}</span>
                </div>
              </div>
            </Panel>
            <Controls />
            <MiniMap nodeColor={(node) => node.data.nodeTemplate?.color || '#9E9E9E'} />
            <Background variant="dots" gap={15} size={1} />
          </ReactFlow>
        </div>
        
        {showPropertyPanel && (
          <PropertyPanel
            selectedNode={selectedNode}
            onUpdateNode={onUpdateNode}
            onClose={() => setShowPropertyPanel(false)}
            allNodes={nodes}
          />
        )}
      </div>
    </div>
  );
}

export default App;
